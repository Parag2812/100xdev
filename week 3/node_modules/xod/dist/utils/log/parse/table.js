"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTable = void 0;
const chalk_1 = __importDefault(require("chalk"));
const __1 = require("../../../");
const _1 = require("./");
function parseTable(table, options) {
    const { showColHead, showRowHead, cols = [], rows = [], select, flip, sort, valueTransform, margin = 0, vMargin = 0, } = options;
    const H = (flip ? (table = __1.flipArray2D(table)) : table).length;
    const W = Math.max(0, ...table.map(v => v.length));
    const d = [];
    const showHead = H <= 5 && W <= 5 ? 0 : 1;
    const hasCol = showColHead === undefined ? showHead : +showColHead;
    const hasRow = showRowHead === undefined ? showHead : +showRowHead;
    const colLen = new Array(W + hasRow).fill(1);
    const rowLen = new Array(H + hasCol).fill(1);
    let count = 0;
    let divider = !!options.showDivider;
    if (W === 0) {
        return {
            v: ['<Empty Table>'],
            w: 13,
            h: 1,
        };
    }
    if (sort) {
        const parseSort = sort
            .map(v => {
            if (typeof v.key === 'number') {
                return {
                    k: v.key,
                    f: v.compareFn,
                };
            }
            else {
                const col = cols.find(c => c.key === v.key);
                if (col) {
                    return {
                        k: cols.indexOf(col),
                        f: v.compareFn,
                    };
                }
                return false;
            }
        })
            .filter(Boolean);
        if (parseSort.length) {
            const sortFn = parseSort.reduce((p, v) => (a, b) => p(a, b) || v.f(a[v.k], b[v.k]), (a, b) => 0);
            table.sort(sortFn);
        }
    }
    // 存在列头时先添加列头的数据
    if (hasCol) {
        const row = [];
        if (hasRow) {
            row.push({ v: [''], w: 0, h: 1 });
        }
        for (let i = 0; i < W; ++i) {
            const v = ((cols[i] && (cols[i].key || cols[i].title)) || i).toString();
            row.push({ v: [chalk_1.default.grey(v)], w: __1.getStringWidth(v), h: 1 });
            colLen[i + hasRow] = Math.max(colLen[i + hasRow], __1.getStringWidth(v) + margin * 2);
        }
        d.push(row);
    }
    // 解析整个表的数据
    for (let h = 0; h < H; ++h) {
        const row = [];
        let maxRowLen = 1;
        if (hasRow) {
            const v = ((rows[h] && (rows[h].key || rows[h].title)) || h).toString();
            const w = __1.getStringWidth(v);
            row.push({ v: [chalk_1.default.grey(v)], w, h: 1 });
            colLen[0] = Math.max(colLen[0], w);
        }
        for (let w = 0, wl = table[h].length; w < W; ++w) {
            if (w < wl) {
                const v = _1.parse(valueTransform ? valueTransform(table[h][w]) : table[h][w]);
                row.push(v);
                colLen[w + hasRow] = Math.max(colLen[w + hasRow], v.w + margin * 2);
                maxRowLen = Math.max(maxRowLen, v.h + vMargin * 2);
                divider = divider || v.h > 1;
                count++;
            }
            else {
                row.push({ v: [''], w: 0, h: 1 });
            }
        }
        rowLen[h + hasCol] = Math.max(rowLen[h + hasCol], maxRowLen);
        d.push(row);
    }
    // 如果列头与行头都存在 写入数据的总数到左上角
    if (hasCol && hasRow) {
        const v = count.toString();
        const w = __1.getStringWidth(v);
        d[0][0] = { v: [chalk_1.default.grey(v)], w, h: 1 };
        colLen[0] = Math.max(colLen[0], w);
    }
    // 将每个单元格的数据格式化（添加左右空格）
    d.forEach((row, hi) => (d[hi] = row.map((ceil, wi) => {
        const shouldW = colLen[wi];
        const shouldH = rowLen[hi];
        const v = ceil.v;
        const u = shouldW - ceil.w;
        v.forEach((str, i) => (v[i] = ' '.repeat(u >> 1) + str + ' '.repeat((u + 1) >> 1)));
        if (shouldH > ceil.h) {
            const y = shouldH - ceil.h;
            v.unshift(...new Array(y >> 1).fill(' '.repeat(shouldW)));
            v.push(...new Array((y + 1) >> 1).fill(' '.repeat(shouldW)));
        }
        ceil.w = shouldW;
        ceil.h = shouldH;
        return ceil;
    })));
    // 存在选择
    if (select) {
        const selectArr = Array.isArray(select) ? select : [select];
        selectArr.forEach(({ row, col, cell, color }) => {
            if (row !== undefined) {
                for (let i = 0; i < W; ++i) {
                    d[row + hasCol][i + hasRow].b = color || 'bgCyan';
                }
            }
            if (col !== undefined) {
                for (let i = 0; i < H; ++i) {
                    d[i + hasCol][col + hasRow].b = color || 'bgCyan';
                }
            }
            if (cell !== undefined) {
                d[cell[0] + hasCol][cell[1] + hasRow].b = color || 'bgCyan';
            }
        });
    }
    const r = [];
    r.push(chalk_1.default.grey(`╭${colLen.map(v => '─'.repeat(v)).join('┬')}╮`));
    for (let h = 0, hl = d.length; h < hl; ++h) {
        if (divider ? h !== 0 : hasCol && h === 1) {
            r.push(chalk_1.default.grey(`├${colLen.map(v => '─'.repeat(v)).join('┼')}┤`));
        }
        for (let rh = 0, rhl = rowLen[h]; rh < rhl; ++rh) {
            let s = chalk_1.default.grey('│');
            for (let w = 0, wl = d[h].length; w < wl; ++w) {
                if (w !== 0) {
                    s += chalk_1.default.grey('│');
                }
                s += d[h][w].b ? chalk_1.default[d[h][w].b](d[h][w].v[rh]) : d[h][w].v[rh];
            }
            r.push(s + chalk_1.default.grey('│'));
        }
    }
    r.push(chalk_1.default.grey(`╰${colLen.map(v => '─'.repeat(v)).join('┴')}╯`));
    return {
        v: r,
        w: __1.getStringWidth(r[0]),
        h: r.length,
    };
}
exports.parseTable = parseTable;
