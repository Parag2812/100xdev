"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const chalk_1 = __importDefault(require("chalk"));
const __1 = require("../../../");
const table_1 = require("./table");
const btree_1 = require("./btree");
const tree_1 = require("./tree");
function parse(data, options = {}) {
    const t = typeof data;
    if (data !== null && t === 'object') {
        if (data instanceof Set) {
            // Set
            return parse(Array.from(data), options);
        }
        else if (data instanceof Map) {
            // Map
            const table = Array.from(data.entries());
            table.unshift(['<Key>', '<Value>']);
            return parse(table, {
                ...options,
                showColHead: false,
                showRowHead: false,
            });
        }
        else if (Array.isArray(data)) {
            if (data.length === 0) {
                return {
                    v: ['<Empty Array>'],
                    w: 13,
                    h: 1,
                };
            }
            else if (Array.isArray(data[0])) {
                // Array2D
                return table_1.parseTable(data, options);
            }
            else if (options.isHeap) {
                // 用数组表示的堆
                return btree_1.parseBinaryTree(__1.arrayHeapToBinaryTree(data), options);
            }
            else if (options.isTree) {
                // 用数组表示的树
                return tree_1.parseTree(__1.array1dToBinayTree(data), options);
            }
            else {
                // Array1D
                return parse(__1.array1dTo2d(data), options);
            }
        }
        else if (__1.isPlainObj(data)) {
            if (data.hasOwnProperty('next')) {
                // LinkList
                const r = [];
                let d = data;
                while (d) {
                    r.push(d.val);
                    d = d.next;
                }
                return parse(d, options);
            }
            else if (data.hasOwnProperty('left')) {
                // Binary Tree
                return btree_1.parseBinaryTree(data, options);
            }
            else if (data.hasOwnProperty('childs')) {
                // Tree
                return tree_1.parseTree(data, options);
            }
            else {
                // Plain Obj
                const table = Object.entries(data);
                return parse(table, {
                    ...options,
                    showColHead: true,
                    showRowHead: false,
                    cols: [{ key: '<Key>' }, { key: '<Value>' }],
                });
            }
        }
    }
    const v = data + '';
    const c = t === 'string' ? 'green' : t === 'undefined' || data === null ? 'grey' : 'yellow';
    return { v: [chalk_1.default[c](v)], w: __1.getStringWidth(v), h: 1 };
}
exports.parse = parse;
