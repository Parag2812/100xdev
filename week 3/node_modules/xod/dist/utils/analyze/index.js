"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.analyze = void 0;
const log_1 = require("../log");
const chalk_1 = __importDefault(require("chalk"));
const algorithm_1 = require("../../algorithm");
const tagMap = new Map();
const state = {
    analyzing: false,
};
function logAnalyzeResults(res, options) {
    const cols = [{ key: 'Name' }, { key: 'Avg' }, { key: 'Calls' }];
    const tagIndexMap = new Map();
    let tagInd = 3;
    const table = res.map(r => {
        const u = [r.name, r.avgTime, r.callTimes];
        r.tags.forEach(([t, n]) => {
            if (!tagIndexMap.has(t)) {
                cols.push({ key: t });
                tagIndexMap.set(t, tagInd++);
            }
            u[tagIndexMap.get(t)] = chalk_1.default.yellow(n);
        });
        return u;
    });
    const W = cols.length;
    for (let h = 0, H = table.length; h < H; ++h) {
        for (let w = 3; w < W; ++w) {
            if (table[h][w] === undefined) {
                table[h][w] = chalk_1.default.grey('-');
            }
        }
    }
    log_1.log(table, {
        margin: 1,
        showColHead: true,
        cols,
        showDivider: true,
        ...(typeof options.sort === 'string'
            ? {
                sort: [{ key: options.sort, compareFn: algorithm_1.defaultCompareFn }],
            }
            : {}),
    });
}
function analyze(fns, cb, options = {}) {
    const results = fns.map(fn => {
        let sTime = 0;
        let nCall = 0;
        tagMap.clear();
        cb(((...args) => {
            const t = Date.now();
            const fnResult = fn(...args);
            sTime += Date.now() - t;
            nCall++;
            return fnResult;
        }));
        const result = {
            name: fn.name,
            sumTime: sTime,
            avgTime: sTime / nCall,
            callTimes: nCall,
            tags: Array.from(tagMap.entries()),
        };
        tagMap.clear();
        return result;
    });
    logAnalyzeResults(results, options);
}
exports.analyze = analyze;
analyze.tag = (name) => {
    tagMap.set(name, (tagMap.get(name) || 0) + 1);
    return true;
};
